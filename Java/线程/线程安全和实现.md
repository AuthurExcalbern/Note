## 定义

**当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。**

要求线程安全的代码都必须具备一个特征：
- **代码本身封装了所有必要的正确性保障手段**（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。

## 分类

按照线程安全的程度由强至弱分成五类

- 不可变：外部的可见状态永远不会改变，在多个线程之中永远是一致的状态。
  - 一定是线程安全的
  - 如何实现：
    - 如果共享数据是一个基本数据类型，只要在定义时用final关键字修饰；
    - 如果共享数据是一个对象，最简单的方法是把对象中带有状态的变量都声明为final。

- 绝对线程安全：完全满足之前给出的线程安全的定义，即达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”。

- 相对线程安全：能保证对该对象单独的操作是线程安全的，在调用时无需做额外保障措施，但对于一些特定顺序的连续调用，可能需要在调用端使用额外的同步措施来保证调用的正确性。
  - 是通常意义上所讲的线程安全
  - 大部分的线程安全类都属于这种类型，如`Vector、HashTable、Collections#synchronizedCollection()`包装的集合...

- 线程兼容：对象本身非线程安全的，但可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，
  - 是通常意义上所讲的非线程安全
  - Java API中大部分类都是属于线程兼容的，如ArrayList和HashMap...

- 线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

## 线程安全的实现

可分成两大手段，本篇重点在虚拟机本身
- 通过代码编写实现线程安全
- 通过虚拟机本身实现同步与锁

### 互斥同步(Mutual Exclusion＆Synchronization）

- 含义：
  - 同步：在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。
  - 互斥：是实现同步的一种手段，主要的互斥实现方式:
    - 临界区（Critical Section）
    - 互斥量（Mutex）
    - 信号量（Semaphore）

互斥是因，同步是果；互斥是方法，同步是目的。

- 属于**悲观并发策略**，即认为只要不做正确的同步措施就肯定会出现问题，因此无论共享数据是否真的会出现竞争，都要加锁。

- 最大的**问题**是进行线程阻塞和唤醒所带来的性能问题，也称为**阻塞同步**（Blocking Synchronization）

- 手段：

  - 使用`synchronized`关键字：
    - 原理：
      - 编译后会在同步块的前后分别形成`monitorenter`和`monitorexit`这两个字节码指令，
      - 并通过一个`reference`类型的参数来指明要锁定和解锁的对象。
      - 若明确指定了对象参数，则取该对象的`reference`；
      - 否则，会根据`synchronized`修饰的是实例方法还是类方法去取对应的对象实例或Class对象来作为锁对象。
    - 过程：
      - 执行`monitorenter`指令时先要尝试获取对象的锁。
      - 若该对象没被锁定或者已被当前线程获取，那么锁计数器+1；
      - 而在执行monitorexit指令时，锁计数器-1；
      - 当锁计数器=0时，锁就被释放；
      - 若获取对象锁失败，那当前线程会一直被阻塞等待，直到对象锁被另外一个线程释放为止。
    - 特别注意： 
      - `synchronized`同步块对同一条线程来说是可重入的，不会出现自我锁死的问题；
      - 还有，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。

  - 使用重入锁`ReentrantLock`：
    - 相同：用法与`synchronized`很相似，且都可重入。
    - 与`synchronized`的不同：
      - 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
      - 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。
        - 而`synchronized`是非公平的，即在锁被释放时，任何一个等待锁的线程都有机会获得锁。
        - `ReentrantLock`默认情况下也是非公平的，但可以通过带布尔值的构造函数改用公平锁。
      - 锁绑定多个条件：
        - 一个`ReentrantLock`对象可以通过多次调用`newCondition()`同时绑定多个`Condition`对象。
        - 而在`synchronized`中，锁对象的`wait()`和`notify()`或`notifyAl()`只能实现一个隐含的条件，若要和多于一个的条件关联不得不额外地添加一个锁。
    - 选择：在`synchronized`能实现需求的情况下，优先考虑使用它来进行同步。

### 非阻塞同步（Non-Blocking Synchronization）：

- 基于冲突检测的乐观并发策略，即先进行操作，若无其他线程争用共享数据，操作成功；反之产生了冲突再去采取其他的补偿措施。

- 为了保证操作和冲突检测这两步具备原子性，需要用到硬件指令集，比如：
  - 测试并设置（Test-and-Set）
  - 获取并增加（Fetch-and-Increment）
  - 交换（Swap）
  - 比较并交换（Compare-and-Swap,CAS）
  - 加载链接/条件存储（Load-Linked/Store-Conditional,LL/SC）

### 无同步方案

定义：不用同步的方式保证线程安全，因为有些代码天生就是线程安全的。

下面举两个例子：
- 重入代码（Reentrant Code）/纯代码（Pure Code）
  - 含义：可在代码执行的任何时刻中断它去执行另外一段代码，当控制权返回后原来的程序并不会出现任何错误。
  - 共同特征：不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法...
  - 判定依据：如果一个方法，它的返回结果是可预测的，只要输入相同的数据就都能返回相同的结果，就满足可重入性。

满足可重入性的代码一定是线程安全的，反之，满足线程安全的代码不一定是可重入的。

- 程本地存储（Thread Local Storage）
  - 含义：把共享数据的可见范围限制在同一个线程之内，无须同步就能保证线程之间不出现数据争用的问题。
  - 使用`ThreadLocal`类可实现线程本地存储的功能：每个线程的Thread对象中都有一个ThreadLocalMap对象，它存储了一组以ThreadLocal.threadLocalHashCode为key、以本地线程变量为value的键值对，而ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，也就包含了一个独一无二的threadLocalHashCode值，通过这个值就可以在线程键值值对中找回对应的本地线程变量。