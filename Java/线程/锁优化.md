## 适应性自旋（Adaptive Spinning）

- 背景：
  - 互斥同步在实现阻塞和唤醒时需要挂起线程和恢复线程的操作，都需要转入内核态中完成，很影响系统的并发性能；
  - 同时，在许多应用上共享数据的锁定状态只是暂时，没必要去挂起和恢复线程。

- 自旋锁：
  - 当物理机器有多个处理器使得多个线程同时并行执行时，先让后请求锁的线程等待，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，这时只需让线程执行一个**忙循环**，即自旋。
  - 注意：自旋等待不能代替阻塞，它虽然能避免线程切换的开销，但会占用处理器时间，因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍未成功获锁，就需要挂线程了

- 自适应自旋锁：自旋的时间不再固定，而是由该锁上的上次自旋时间及锁的拥有者的状态共同决定。
  - 具体表现是：
    - 如果对于某个锁，自旋等待刚刚成功获得，且持有锁的线程正在运行中，那么虚拟机很可能允许自旋等待的时间更久点。
    - 如果对于某个锁，自旋很少成功获得过，那么很可能以后将省略自旋等待这个锁，避免浪费处理器资源。

## 锁消除（Lock Elimination）

- 锁消除：指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

- 判定依据：如果一段代码中堆上的所有数据都不会逃逸出去被其他线程访问到，可把它们当做栈上数据对待，即线程私有的，无须同步加锁。

## 锁粗化（Lock Coarsening）

一般情况下，会将同步块的作用范围限制到只在共享数据的实际作用域中才进行同步，使得需要同步的操作数量尽可能变小，保证就算存在锁竞争，等待锁的线程也能尽快拿到锁。

但如果反复操作对同一个对象进行加锁和解锁，即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗，此时，虚拟机将会把加锁同步的范围粗化到整个操作序列的外部，这样只需加一次锁。

## 轻量级锁（Lightweight Locking）

- 目的：在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，注意不是用来代替重量级锁的。

首先先理解HotSpot虚拟机的对象头的内存布局：分为两部分
- 第一部分用于存储对象自身的运行时数据，这部分被称为`Mark Word`，是实现轻量级锁和偏向锁的关键。如哈希码、GC分代年龄等。
- 另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象还会有一个额外的部分用于存储数组长度。

![](https://upload-images.jianshu.io/upload_images/5494434-1505a0857b2c330e.png)

- 加锁过程：代码进入同步块时，如果同步对象未被锁定（锁标志位为01），虚拟机会在当前线程的栈帧中建立一个名为Lock Record的空间，用于存储锁对象Mark Word的拷贝。如下图。

![](https://upload-images.jianshu.io/upload_images/5494434-141a27b5e8afbccd.png)

之后虚拟机会尝试用CAS操作将对象的Mark Word更新为指向Lock Record的指针。若更新动作成功，那么当前线程就拥有了该对象的锁，且对象Mark Word的锁标志位变为00，即处于轻量级锁定状态；反之，虚拟机会先检查对象的Mark Word是否指向当前线程的栈帧，若当前线程已有该对象的锁，可直接进入同步块继续执行，否则说明改对象已被其他线程抢占。如下图。

![](https://upload-images.jianshu.io/upload_images/5494434-ef0605aa3f39e221.png)

另外，如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志位变为10，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。

- 解锁过程：若对象的Mark Word仍指向着线程的Lock Record，就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。若替换成功，那么就完成了整个同步过程；反之，说明有其他线程尝试获取该锁，那么就要在释放锁的同时唤醒被挂起的线程。

- 优点：因为对于绝大部分的锁，在整个同步周期内都是不存在竞争的，所以轻量级锁通过使用CAS操作消除同步使用的互斥量。

## 偏向锁（Biased Locking）

- 目的：消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。

- 含义：偏向锁会偏向于第一个获得它的线程，如果在后面的执行中该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

- 加锁过程：启用偏向锁的锁对象在第一次被线程获取时，Mark Word的锁标志位会被设置为01，即偏向模式，同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中。若操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时都可不再进行任何同步操作。

- 解锁过程：当有另外的线程去尝试获取这个锁时，根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定01或轻量级锁定00的状态，后续的同步操作就如轻量级锁执行过程。如下图。

![](https://upload-images.jianshu.io/upload_images/5494434-604f74504d1e06c1.png)

- 优点：可提高带有同步但无竞争的程序性能，但若程序中大多数锁总被多个线程访问，此模式就没必要了。
