### String & StringBuffer & StringBuilder

- 常量 变量
  - String是字符串常量，
  - 而StringBuffer、StringBuilder都是字符串变量，
  - 即String对象一创建后不可更改，而后两者的对象是可更改的

- 线程安全
  - StringBuffer是线程安全的，
  - 而StringBuilder是非线程安全的，
  - 这是由于StringBuffer对方法加了同步锁或者对调用的方法加了同步锁

- 适用
  - String更适用于少量的字符串操作的情况，
  - StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况，
  - StringBuffer适用于多线程下在字符缓冲区进行大量操作的情况

### String a=""和String a=new String("")

- 通过String a=""直接赋值的方式得到的是一个**字符串常量**，存在于常量池；
  - 注意，相同内容的字符串在常量池中只有一个，
  - 即如果池已包含内容相等的字符串会返回池中的字符串，反之会将该字符串放入池中

- 通过new String("")创建的字符串不是常量是**实例对象**，
  - 会在堆内存开辟空间并存放数据，
  - 且每个实例对象都有自己的地址空间

### Object的equal()和==

- equals()：是Object的公有方法，具体含义取决于如何重写，比如String的equals()比较的是两个字符串的内容是否相同

- "==" ：
  - 对于基本数据类型来说，比较的是两个变量值是够是否相等，
  - 对于引用类型来说，比较的是两个对象的内存地址是否相同

### 原生类型与包装器类型

- 基本数据类型: 直接存储在内存或者内存栈上而Java语言里面只有这八种数据类型是这种存储模型； 
- 引用数据类型:“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的。

- 装箱就是自动将基本数据类型转换为包装器类型
- 拆箱就是自动将包装器类型转换为基本数据类型

[Java 原生类型与包装器类型深度剖析](https://blog.csdn.net/justloveyou_/article/details/52651211)


### int & Integer

- Integer是int的包装类，int则是java的一种基本数据类型

- Integer变量必须实例化后才能使用，而int变量不需要

- Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值

- Integer的默认值是null，int的默认值是0

### 静态内部类和非静态内部类

内部类就是定义在另外一个类里面的类。它隐藏在外部类中，封装性更强，不允许除外部类外的其他类访问它；但它可直接访问外部类的成员。

- 静态内部类是指被声明为static的内部类，可不依赖外部类实例化；而非静态内部类需要通过生成外部类来间接生成。

- 静态内部类只能访问外部类的静态成员变量和静态方法，而非静态内部类由于持有对外部类的引用，可以访问外部类的所用成员

[Java 内部类详解](https://www.runoob.com/w3cnote/java-inner-class-intro.html)

### final、finally、finalize()

- final关键字表示不可更改，具体体现在：
  - final修饰的变量必须要初始化，且赋初值后不能再重新赋值
  - final修饰的方法不能被子类重写
  - final修饰的类不能被继承

- finally：和try、catch成套使用进行异常处理，无论是否捕获或处理异常，finally块里的语句都会被执行，在以下4种特殊情况下，finally块才不会被执行：
  - 在finally语句块中发生了异常
  - 在前面的代码中用了System.exit()退出程序
  - 程序所在的线程死亡
  - 关闭CPU

- finalize()：是Object中的方法，当垃圾回收器将回收对象从内存中清除出去之前会调用finalize()，但此时并不代表该回收对象一定会“死亡”，还有机会“逃脱”

### 匿名内部类中使用局部变量要用final修饰

- 一方面，由于方法中的局部变量的生命周期很短，一旦方法结束变量就要被销毁，为了保证在内部类中能找到外部局部变量，通过final关键字可得到一个外部变量的引用；

- 另一方面，通过final关键字也不会在内部类去做修改该变量的值，保护了数据的一致性。

### Object公有方法

- `equals()`： 和==作用相似
- `hashCode()`：用于哈希查找，重写了equals()一般都要重写该方法
- `getClass()`： 获取Class对象
- `wait()`：让当前线程进入等待状态，并释放它所持有的锁
- `notify()&notifyAll()`： 唤醒一个（所有）正处于等待状态的线程
- `toString()`：转换成字符串

引申：equals()和==的不同、在synchronized 同步代码块里wait()和notify()&notifyAll()如何配合、hashCode()和equals()的关系、获取Class对象还有什么方法

### 重写 & 覆盖

- 重写`override`:表示子类重写父类的方法；
- 重载表示有多个同名函数同时存在，区别在于有不同的参数个数或类型