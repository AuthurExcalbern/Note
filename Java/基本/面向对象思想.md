## 面向对象&面向过程

|面向过程|面向对象|
|-|-|
|以功能（行为）为导向|以数据（属性）为导向|
|按模块化的设计，就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用|将具有相同一个或者多个属性的物体抽象为“类”，将他们包装起来；建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为|

---
C++ 与 Java 的区别：

- Java是完全面向对象的语言，所有函数和变量部必须是类的一部分。
  - 除了基本数据类型之外，其余的都作为类对象，包括数组。
  - 对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。

- C++ 是混合型面向对象程序设计语言，c++ 允许将函数和变量定义为全局的。

## 四大特征

### 抽象

抽象：从众多的事物中抽取出共同的、本质性的**属性和行为方法**

好处：**防止代码冗余/重复**



C++ 与 Java 的区别：

Java使用抽象类/抽象函数：
- 抽象函数：
  - 用abstract来修饰，没有具体实现，不能被调用
  - 不可以使用`private`/`static`修饰 -> 子类不能访问/没有主体
  - `public abstract void mMethod();`
- 抽象类
  - 抽象类不能被实例化，但有自己的构造方法
    - new 一个类时会优先调用父类的构造方法
    - 对于抽象类中的非statci(静态)和非abstract(抽象)方法中的this关键字代表的是它的继承类，而非抽象类本身
  - 不能使用final关键字修饰，因为final修饰的类是无法被继承
  - 有抽象方法，那么这个类一定是抽象类，但反之则不然。
```java
public abstract class A{
    public void mothod1(){}
    public abstract void mothod2();
}
```

C++使用虚函数/纯虚函数：
- 虚函数：
  - 与C++抽象类无关，有实现，可以被直接使用
- 纯虚函数：
  - 含有纯虚函数的类才为抽象类
  - 没有实现，要在子类中实现后才可以被调用
```c++
class Shape 
{
public:
   // 纯虚函数
   virtual int getArea() = 0;
};

class Rectangle: public Shape
{
public:
   int getArea(){ 
      return 10; 
   }
};
```

---

### 封装

封装：
- 把抽象出来的属性和方法封装为类，封装为类后会隐藏内部细节，提供不同级别的保护

好处：
- **将接口和实现细节分离开来**
- **安全性**

---


### 继承

继承：某类获得另一个类型的属性和方法

好处：
- **代码重用**
- **重写方法形成多态**



C++ 与 Java 的区别：

- Java **只能单继承**：`public class B extends A{}`
- C++
  - **可以多继承**：`class A: public B,public c{};`
  - 二义性解决办法：[虚继承机制](https://blog.csdn.net/wue1206/article/details/81272053)

---

### 多态

多态：接口/抽象类的多种不同实现，方法的多种重载

- 静态多态（编译时多态）：函数重载
```java
class Calculater{
    public int add(int a,int b) {//两个int数相加
        return a + b;
    }
    public double add(double a, double b) {//两个double数进行相加
        return a + b ;
    }
}
```

- 动态多态（运行时多态）：接口/抽象类的不同实现的动态绑定
```java
class Animal{
    public int id(){return 0;}
}
class Cat extends Animal{
    public int id(){return 1;}
}

Animal a = new Cat();
```

好处：
- **代码重用**
- **提高可扩充性和可维护性**

---


## 六大基本原则
### 单一职责原则SRP(Single Responsibility Principle)

类/方法的功能单一，把不同的功能封装到不同的类/方法中。

好处：
- 需修改某功能代码时，不必牵连另一块代码

### 开放封闭原则OCP(Open－Close Principle)

对扩展开放，对修改封闭

关键在于**公共部分的抽象**，使得我们只需扩展代码，无需修改代码

比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码

好处：
- 可扩展性，维护性

### 里式替换原则LSP(the Liskov Substitution Principle LSP)

所有引用基类的地方必须能透明地使用其子类的对象

好处：
- 向以前的代码兼容

### 依赖倒置原则DIP(the Dependency Inversion Principle DIP)

依赖高层模块不依赖低层次模块，依赖抽象不依赖具体细节

例如：我们出行不能依赖于单车、火车、汽车，应该依赖于交通工具。

好处：
- 灵活性，维护性

### 接口隔离原则ISP(the Interface Segregation Principle ISP)

某个类不应该依赖它不需要的接口，应该建立在最小接口上。

将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。

好处：
- 系统解开耦合，从而容易重构、更改和重新部署，让客户端依赖的接口尽可能地小

### 迪米特法则（Law of Demeter,简称LoD） / 最少知识原则

一个对象应该对其他对象有最少的了解

不必关心的隐藏内部细节和具体实现，只需调用对象提供的功能接口